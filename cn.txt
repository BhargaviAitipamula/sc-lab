1)Subnetting
#include <stdio.h>
unsigned int toInt(unsigned int a, unsigned int b, unsigned int c, unsigned int d) {
    return (a << 24) | (b << 16) | (c << 8) | d;
}
int main() {
    int a, b, c, d, prefix;
    unsigned int ip, mask, network, broadcast;
    unsigned int first, last;

    printf("Enter IP address: ");
    scanf("%d.%d.%d.%d", &a, &b, &c, &d);

    printf("Enter prefix: ");
    scanf("%d", &prefix);

    ip = toInt(a, b, c, d);
    mask = (prefix == 0) ? 0 : (~0u << (32 - prefix));

    network   = ip & mask;
    broadcast = network | ~mask;

    first = (prefix == 32) ? network : network + 1;
    last  = (prefix == 32) ? network : broadcast - 1;

    printf("\nNetwork:   %u.%u.%u.%u\n",
           network >> 24 & 255, network >> 16 & 255, network >> 8 & 255, network & 255);

    printf("Broadcast: %u.%u.%u.%u\n",
           broadcast >> 24 & 255, broadcast >> 16 & 255, broadcast >> 8 & 255, broadcast & 255);

    printf("Mask:      %u.%u.%u.%u\n",
           mask >> 24 & 255, mask >> 16 & 255, mask >> 8 & 255, mask & 255);

    printf("First host: %u.%u.%u.%u\n",
           first >> 24 & 255, first >> 16 & 255, first >> 8 & 255, first & 255);

    printf("Last host:  %u.%u.%u.%u\n",
           last >> 24 & 255, last >> 16 & 255, last >> 8 & 255, last & 255);

    return 0;
}

2)Distance Vector routing
#include <stdio.h>
#define INF 9999
#define MAX 10
struct node {
    int dist[MAX];
    int nextHop[MAX];
} rt[MAX];
int main() {
    int cost[MAX][MAX];
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    printf("Enter the cost matrix (use 9999 for INF):\n");
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            scanf("%d", &cost[i][j]);
            rt[i].dist[j] = cost[i][j];
            if (cost[i][j] != 9999 && i != j)
                rt[i].nextHop[j] = j;
            else
                rt[i].nextHop[j] = -1;
        }
    int updated;
    do {
        updated = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (rt[i].dist[j] > cost[i][k] + rt[k].dist[j]) {
                        rt[i].dist[j] = cost[i][k] + rt[k].dist[j];
                        rt[i].nextHop[j] = k;
                        updated = 1;
                    }
                }
            }
        }
    } while (updated);
    for (int i = 0; i < n; i++) {
        printf("\nRouting table for node %d:\n", i);
        printf("Destination\tNext Hop\tDistance\n");
        for (int j = 0; j < n; j++)
            printf("%d\t\t%d\t\t%d\n", j, rt[i].nextHop[j], rt[i].dist[j]);
    }
    return 0;
}

3)Dijkstras
#include <stdio.h>
#include <limits.h>
#include <stdbool.h>
#define V 7  
int minDistance(int dist[], bool sptSet[]) {
    int min = INT_MAX, min_index = -1;
    for (int v = 0; v < V; v++)
        if (!sptSet[v] && dist[v] <= min)
            min = dist[v], min_index = v;
    return min_index;
}
void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool sptSet[V];
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;
    dist[src] = 0;
    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet);
        sptSet[u] = true;
        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX
                && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }
    for (int i = 1; i < V; i++)
        printf("Distance from source to %d: %d\n", i, dist[i]);
}
int main() {
    int source = 0;


    // printf("Graph (7 nodes, source: 0):\n");
    // for (int i = 0; i < V; i++) {
    //     for (int j = 0; j < V; j++) {
    //         char ch;
    //         while (scanf("%c", &ch) == 1 && (ch < '0' || ch > '9')) {}
    //         ungetc(ch, stdin);
    //         scanf("%d", &graph[i][j]);
    //     }
    // }
int graph[V][V]={{0, 0, 1, 2, 0, 0, 0},
{0, 0, 2, 0, 0, 3, 0},
{1, 2, 0, 1, 3, 0, 0},
{2, 0, 1, 0, 0, 0, 1},
{0, 0, 3, 0, 0, 2, 0},
{0, 3, 0, 0, 2, 0, 1},
{0, 0, 0, 1, 0, 1, 0}};
    dijkstra(graph, source);
    return 0;
}

4) DNS
import java.net.*;
import java.util.Scanner;
public class b {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Welcome to the Simple DNS Resolver!");
        System.out.println("Enter a domain name to resolve (or type 'exit' to quit):");
        while (true) {
            System.out.print("Domain: ");
            String domain = scanner.nextLine();

            if ("exit".equalsIgnoreCase(domain)) {
                System.out.println("Exiting DNS Resolver. Goodbye!");
                break;
            }
            try {
                InetAddress[] addresses = InetAddress.getAllByName(domain);
                System.out.println("IP addresses for " + domain + ":");

                for (InetAddress address : addresses) {
                    System.out.println(" - " + address.getHostAddress());
                }
            } catch (UnknownHostException e) {
                System.out.println("Could not resolve domain: " + e.getMessage());
            }
        }
        scanner.close();
    }
}

5)Bucket
#include <stdio.h>


int main() {
    int bucket_size, output_rate, input_packets, stored = 0, time;


    printf("Enter bucket size: ");
    scanf("%d", &bucket_size);


    printf("Enter output rate (leak rate): ");
    scanf("%d", &output_rate);


    printf("Enter number of cycles (time units): ");
    scanf("%d", &time);


    while (time--) {
        printf("\nEnter number of packets arriving: ");
        scanf("%d", &input_packets);


        // Check for overflow condition
        if (stored + input_packets > bucket_size) {
            printf("Bucket overflow! %d packets dropped.\n", (stored + input_packets) - bucket_size);
            stored = bucket_size;
        } else {
            stored += input_packets;
        }


        printf("Packets currently in bucket: %d\n", stored);


        // Leak / Send packets
        if (stored >= output_rate) {
            stored -= output_rate;
            printf("Packets sent: %d\n", output_rate);
        } else {
            printf("Packets sent: %d\n", stored);
            stored = 0;
        }


        printf("Packets left in bucket after sending: %d\n", stored);
    }


    return 0;
}

6)ping
import java.net.*;
import java.io.*;
public class b {
    public static void main(String[] args) {
        String hostname = args[0];
        try {
            System.out.println("Pinging " + hostname + "...");
            InetAddress inetAddress = InetAddress.getByName(hostname);
            boolean isReachable = inetAddress.isReachable(5000);
            if (isReachable) {
                System.out.println("Host " + hostname + " is reachable.");
                System.out.println("IP Address: " + inetAddress.getHostAddress());
            } else {
                System.out.println("Host " + hostname + " is not reachable.");
            }
        } catch (Exception e) {
            System.out.println("Unknown host: " + hostname);
        }
    }
}


7)XOR
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();

        System.out.println("Char\tASCII\tAND127\tXOR127");
        for(char c : s.toCharArray())
            System.out.println(c+"\t"+(int)c+"\t"+(c&127)+"\t"+(c^127));
    }
}
XOR

